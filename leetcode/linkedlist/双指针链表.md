
# 双指针 链表

## 19. Remove Nth Node From End of List 删除链表的倒数第 N 个结点 中等

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

示例 1：

> ![](../../pictures/19_1.jpg "")
>
> 输入：head = [1,2,3,4,5], n = 2
>
> 输出：[1,2,3,5]

示例 2：

> 输入：head = [1], n = 1
>
> 输出：[]

示例 3：

> 输入：head = [1,2], n = 1
>
> 输出：[1]
 
提示：

- 链表中结点的数目为 sz
- 1 <= sz <= 30
- 0 <= Node.val <= 100
- 1 <= n <= sz
 
**进阶**：你能尝试使用一趟扫描实现吗？

### 解法一：快慢指针法（最优解）

这种方法使用两个指针，一个快指针和一个慢指针。快指针先向前移动 `n` 步，然后快慢指针同时移动，直到快指针到达链表的末尾。此时，慢指针指向倒数第 `n` 个节点的前一个节点，方便进行删除操作。

**复杂度分析**

- 时间复杂度：O(n)​​
- 空间复杂度：O(1)​​

​​最优解原因​​：只需一次遍历，空间效率最高。

```
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 创建一个虚拟头节点，方便处理删除头节点的情况
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        // 初始化快慢指针
        ListNode fast = dummy;
        ListNode slow = dummy;

        // 快指针先向前移动 n 步
        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }

        // 同时移动快慢指针，直到快指针到达链表末尾
        while (fast != null && fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }

        // 此时 slow 指向倒数第 n 个节点的前一个节点
        // 将 slow 的 next 指向下下个节点，从而删除倒数第 n 个节点
        slow.next = slow.next.next;

        return dummy.next;
    }
}
```

## 1721. Swapping Nodes in a Linked List 交换链表中的节点 中等

给你链表的头节点 head 和一个整数 k 。

**交换** 链表正数第 k 个节点和倒数第 k 个节点的值后，返回链表的头节点（链表 **从 1 开始索引**）。

示例 1：

> ![](../../pictures/1721_1.jpg "")
>
> 输入：head = [1,2,3,4,5], k = 2
>
> 输出：[1,4,3,2,5]

示例 2：

> 输入：head = [7,9,6,6,7,8,3,0,9,5], k = 5
>
> 输出：[7,9,6,6,8,7,3,0,9,5]

示例 3：

> 输入：head = [1], k = 1
>
> 输出：[1]

示例 4：

> 输入：head = [1,2], k = 1
> 
> 输出：[2,1]

示例 5：

> 输入：head = [1,2,3], k = 2
>
> 输出：[1,2,3]
 
提示：

- 链表中节点的数目是 n
- 1 <= k <= n <= 105
- 0 <= Node.val <= 100


### 双指针解法（最优解）

**复杂度分析**
- 时间复杂度：O(n)
- 空间复杂度：O(1)
最优解原因：只需一次遍历即可定位和交换节点，空间效率最高。

```
class Solution {
    public ListNode swapNodes(ListNode head, int k) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        // 初始化指针
        ListNode fast = dummy, slow = dummy;
        ListNode firstPrev = null, secondPrev = null;

        // 找到第k个节点及其前驱
        for (int i = 0; i < k; i++) {
            firstPrev = fast;
            fast = fast.next;
        }
        ListNode first = fast;

        // 找到倒数第k个节点及其前驱
        while (fast != null) {
            secondPrev = slow;
            slow = slow.next;
            fast = fast.next;
        }
        ListNode second = slow;

        // 特殊情况处理：两个节点相同
        if (first == second) {
            return dummy.next;
        }

        // 交换节点
        firstPrev.next = second;
        secondPrev.next = first;

        ListNode temp = first.next;
        first.next = second.next;
        second.next = temp;

        return dummy.next;
    }
}
```

