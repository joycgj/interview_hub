
# 双指针 链表

## 19. Remove Nth Node From End of List 删除链表的倒数第 N 个结点 中等

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

示例 1：

> ![](../../pictures/19_1.jpg "")
>
> 输入：head = [1,2,3,4,5], n = 2
>
> 输出：[1,2,3,5]

示例 2：

> 输入：head = [1], n = 1
>
> 输出：[]

示例 3：

> 输入：head = [1,2], n = 1
>
> 输出：[1]
 
提示：

- 链表中结点的数目为 sz
- 1 <= sz <= 30
- 0 <= Node.val <= 100
- 1 <= n <= sz
 
**进阶**：你能尝试使用一趟扫描实现吗？

### 解法一：快慢指针法（最优解）

这种方法使用两个指针，一个快指针和一个慢指针。快指针先向前移动 `n` 步，然后快慢指针同时移动，直到快指针到达链表的末尾。此时，慢指针指向倒数第 `n` 个节点的前一个节点，方便进行删除操作。

**复杂度分析**

- 时间复杂度：O(n)​​
- 空间复杂度：O(1)​​

​​最优解原因​​：只需一次遍历，空间效率最高。

```
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 创建一个虚拟头节点，方便处理删除头节点的情况
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        // 初始化快慢指针
        ListNode fast = dummy;
        ListNode slow = dummy;

        // 快指针先向前移动 n 步
        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }

        // 同时移动快慢指针，直到快指针到达链表末尾
        while (fast != null && fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }

        // 此时 slow 指向倒数第 n 个节点的前一个节点
        // 将 slow 的 next 指向下下个节点，从而删除倒数第 n 个节点
        slow.next = slow.next.next;

        return dummy.next;
    }
}
```

## 1721. Swapping Nodes in a Linked List 交换链表中的节点 中等

给你链表的头节点 head 和一个整数 k 。

**交换** 链表正数第 k 个节点和倒数第 k 个节点的值后，返回链表的头节点（链表 **从 1 开始索引**）。

示例 1：

> ![](../../pictures/1721_1.jpg "")
>
> 输入：head = [1,2,3,4,5], k = 2
>
> 输出：[1,4,3,2,5]

示例 2：

> 输入：head = [7,9,6,6,7,8,3,0,9,5], k = 5
>
> 输出：[7,9,6,6,8,7,3,0,9,5]

示例 3：

> 输入：head = [1], k = 1
>
> 输出：[1]

示例 4：

> 输入：head = [1,2], k = 1
> 
> 输出：[2,1]

示例 5：

> 输入：head = [1,2,3], k = 2
>
> 输出：[1,2,3]
 
提示：

- 链表中节点的数目是 n
- 1 <= k <= n <= 105
- 0 <= Node.val <= 100


### 双指针解法（最优解）

**复杂度分析**
- 时间复杂度：O(n)
- 空间复杂度：O(1)
最优解原因：只需一次遍历即可定位和交换节点，空间效率最高。

```
class Solution {
    public ListNode swapNodes(ListNode head, int k) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        // 初始化指针
        ListNode fast = dummy, slow = dummy;
        ListNode firstPrev = null, secondPrev = null;

        // 找到第k个节点及其前驱
        for (int i = 0; i < k; i++) {
            firstPrev = fast;
            fast = fast.next;
        }
        ListNode first = fast;

        // 找到倒数第k个节点及其前驱
        while (fast != null) {
            secondPrev = slow;
            slow = slow.next;
            fast = fast.next;
        }
        ListNode second = slow;

        // 特殊情况处理：两个节点相同
        if (first == second) {
            return dummy.next;
        }

        // 交换节点
        firstPrev.next = second;
        secondPrev.next = first;

        ListNode temp = first.next;
        first.next = second.next;
        second.next = temp;

        return dummy.next;
    }
}
```

## 160. Intersection of Two Linked Lists 相交链表 简单

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。

图示两个链表在节点 c1 开始相交：

![](../../pictures/160_1.png "")

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

示例 1：

> ![](../../pictures/160_2.png "")
>
> 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
>
> 输出：Intersected at '8'
> 
> 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
> 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
> 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
> — 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
 

示例 2：

> ![](../../pictures/160_3.png "")
>
> 输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
>
> 输出：Intersected at '2'
>
> 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
> 从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
> 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

示例 3：

> ![](../../pictures/160_4.png "")
>
> 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
>
> 输出：No intersection
>
> 解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
>
> 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
> 这两个链表不相交，因此返回 null 。
 
提示：

- listA 中节点数目为 m
- listB 中节点数目为 n
- 1 <= m, n <= 3 * 104
- 1 <= Node.val <= 105
- 0 <= skipA <= m
- 0 <= skipB <= n
- 如果 listA 和 listB 没有交点，intersectVal 为 0
- 如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]
 
**进阶**：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？

### 双指针 labuladong p115

如果两个链表没有相交点，是否能够正确地返回null呢？

下述逻辑是可以覆盖这种情况的，相当于 c1 节点是 null 空指针，可以正确返回 null。

**复杂度分析**
- 时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。
- 空间复杂度：O(1)。

```
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // p1指向A链表头结点 p2指向B链表头结点
        ListNode p1 = headA, p2 = headB;
        while (p1 != p2) {
            // p1走一步，如果走到A链表末尾，转到B链表
            if (p1 == null) {
                p1 = headB;
            } else {
                p1 = p1.next;
            }

            // p2走一步，如果走到B链表末尾，转到A链表
            if (p2 == null) {
                p2 = headA;
            } else {
                p2 = p2.next;
            }
        }

        return p1;           
    }
}
```

注意不能写成如下，因为每次都要比较p1和p2，如果直接next，相当于没有比较

```
            if (p1 == null) {
                p1 = headB;
            } 
            p1 = p1.next;
            if (p2 == null) {
                p2 = headA;
            } 
            p2 = p2.next;
```
