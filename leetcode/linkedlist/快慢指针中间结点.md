# 快慢指针 中间结点

## 876. Middle of the Linked List 链表的中间结点 简单

给你单链表的头结点 head ，请你找出并返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。


示例 1：

> ![](../../pictures/876_1.jpg "")
>
> 输入：head = [1,2,3,4,5]
> 
> 输出：[3,4,5]
>
> 解释：链表只有一个中间结点，值为 3 。

示例 2：

> ![](../../pictures/876_2.jpg "")
>
> 输入：head = [1,2,3,4,5,6]
>
> 输出：[4,5,6]
>
> 解释：该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。

提示：

- 链表的结点数范围是 [1, 100]
- 1 <= Node.val <= 100

```
class Solution {
    public ListNode middleNode(ListNode head) {
        // 快指针每次走两步，慢指针每次走一步
        ListNode slow = head, fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;         // 慢指针走一步
            fast = fast.next.next;    // 快指针走两步
        }
        // 当快指针到达末尾时，慢指针正好在中间
        return slow;
    }
}
```

- 时间复杂度：O(n)
- 空间复杂度：O(1)

**说明：** 一次遍历，双指针无额外空间，是最优解。

## 2095. Delete the Middle Node of a Linked List 删除链表的中间节点 中等

给你一个链表的头节点 head 。删除 链表的 中间节点 ，并返回修改后的链表的头节点 head 。

长度为 n 链表的中间节点是从头数起第 ⌊n / 2⌋ 个节点（下标从 0 开始），其中 ⌊x⌋ 表示小于或等于 x 的最大整数。

对于 n = 1、2、3、4 和 5 的情况，中间节点的下标分别是 0、1、1、2 和 2 。
 
示例 1：

> ![](../../pictures/2095_1.png "")
>
> 输入：head = [1,3,4,7,1,2,6]
> 
> 输出：[1,3,4,1,2,6]
>
> 解释：
> 
> 上图表示给出的链表。节点的下标分别标注在每个节点的下方。
>
> 由于 n = 7 ，值为 7 的节点 3 是中间节点，用红色标注。
>
> 返回结果为移除节点后的新链表。 

示例 2：

> ![](../../pictures/2095_2.png "")
>
> 输入：head = [1,2,3,4]
>
> 输出：[1,2,4]
>
> 解释：

> 上图表示给出的链表。

> 对于 n = 4 ，值为 3 的节点 2 是中间节点，用红色标注。

示例 3：

> ![](../../pictures/2095_3.png "")
>
> 输入：head = [2,1]
>
> 输出：[2]
>
> 解释：
>
> 上图表示给出的链表。
>
> 对于 n = 2 ，值为 1 的节点 1 是中间节点，用红色标注。
>
> 值为 2 的节点 0 是移除节点 1 后剩下的唯一一个节点。
 
提示：

- 链表中节点的数目在范围 [1, 105] 内
- 1 <= Node.val <= 105

```
// 使用 dummy 结点的解法（快慢指针 + 前驱节点记录 + dummy头）
class Solution {
    public ListNode deleteMiddle(ListNode head) {
        // 虚拟头结点，简化删除逻辑
        ListNode dummy = new ListNode(-1, head);
        ListNode slow = head;
        ListNode fast = head;
        ListNode prev = dummy;
        
        // 快慢指针：fast 每次走两步，slow 每次走一步
        while (fast != null && fast.next != null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }

        // 删除中间节点：prev 是 slow 的前一个节点
        prev.next = slow.next;
        return dummy.next;
    }
}
```

- 时间复杂度：O(n)，单次遍历
- 空间复杂度：O(1)，仅使用常数指针

## 19. Remove Nth Node From End of List 删除链表的倒数第 N 个结点 中等

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

示例 1：

> ![](../../pictures/19_1.jpg "")
>
> 输入：head = [1,2,3,4,5], n = 2
>
> 输出：[1,2,3,5]

示例 2：

> 输入：head = [1], n = 1
>
> 输出：[]

示例 3：

> 输入：head = [1,2], n = 1
>
> 输出：[1]
 

提示：

- 链表中结点的数目为 sz
- 1 <= sz <= 30
- 0 <= Node.val <= 100
- 1 <= n <= sz
 
进阶：你能尝试使用一趟扫描实现吗？

```
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 创建一个虚拟头节点，方便处理删除头节点的情况
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        // 初始化快慢指针
        ListNode fast = dummy;
        ListNode slow = dummy;

        // 快指针先向前移动 n 步
        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }

        // 同时移动快慢指针，直到快指针到达链表末尾
        while (fast != null && fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }

        // 此时 slow 指向倒数第 n 个节点的前一个节点
        // 将 slow 的 next 指向下下个节点，从而删除倒数第 n 个节点
        slow.next = slow.next.next;

        return dummy.next;
    }
}
```

- 时间复杂度：O(n) 一次遍历链表，n 为链表长度。
- 空间复杂度：O(1) 使用常数指针。

**说明：** 推荐写法，健壮、高效，处理所有边界问题。


## 面试题 02.02. Kth Node From End of List 返回倒数第 k 个节点 

实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。

**注意：** 本题相对原题稍作改动

示例：

> 输入： 1->2->3->4->5 和 k = 2
>
> 输出： 4

**说明：**

给定的 k 保证是有效的。

快慢指针法（最优解）

```
// 最优解：一次遍历，快慢指针
class Solution {
    public ListNode kthToLast(ListNode head, int k) {
        ListNode fast = head;
        ListNode slow = head;

        // 快指针先走 k 步
        for (int i = 0; i < k; i++) {
            fast = fast.next;
        }

        // 快慢指针同时走，直到 fast 到尾部
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }

        // 此时 slow 就是倒数第 k 个节点
        return slow;
    }
}
```
- 时间复杂度：O(n) 一次遍历链表即可，n 是链表长度。
- 空间复杂度：O(1) 只使用常数级别的指针。

**说明：** 这是最推荐、最高效的方法，时间空间最优，逻辑清晰。