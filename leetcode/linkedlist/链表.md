# Linked List Manipulation

## 206. Reverse Linked List 反转链表 简单

给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
 

示例 1：

> ![](../../pictures/206_1.jpg "")
>
> 输入：head = [1,2,3,4,5]
>
> 输出：[5,4,3,2,1]

示例 2：

> ![](../../pictures/111_1.jpg "")
>
> 输入：head = [1,2]
> 输出：[2,1]

示例 3：

> 输入：head = []
>
> 输出：[]
 
提示：

- 链表中节点的数目范围是 [0, 5000]
- -5000 <= Node.val <= 5000

**进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

### **解法 1：迭代法**
**时间复杂度**：O(n)  
**空间复杂度**：O(1)  
**核心思想**：使用三个指针（prev, curr, next）逐步反转链表。

```
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        
        while (curr != null) {
            ListNode next = curr.next; // 保存下一个节点
            curr.next = prev;          // 反转当前节点的指针
            prev = curr;               // prev指针后移
            curr = next;               // curr指针后移
        }
        
        return prev;	// prev最终指向新头节点
    }
}
```

**关键点**：
1. **三指针协同**：`prev` 记录前驱节点，`curr` 处理当前节点，`next` 临时保存后续节点
2. **终止条件**：`curr == null` 时，`prev` 指向新头节点
3. **空间高效**：仅使用常数空间


### **解法 2：递归法**
**时间复杂度**：O(n)  
**空间复杂度**：O(n)（递归栈）  
**思路**：递归到链表末端，回溯时逐层反转指针。

```
class Solution {
    public ListNode reverseList(ListNode head) {
        // 基线条件：空链表或单节点链表
        if (head == null || head.next == null) {
            return head;
        }
        
        ListNode newHead = reverseList(head.next); // 递归反转后续链表
        head.next.next = head; // 反转当前节点与下一节点的指针
        head.next = null;      // 避免循环引用
        
        return newHead; // 始终返回新的头节点
    }
}
```

**关键点**：
1. **递归终止**：链表为空或只剩一个节点时直接返回
2. **回溯反转**：从链表末端向前逐个反转指针
3. **缺点**：链表过长时可能导致栈溢出

---

### **解法 3：头插法（Dummy Node）**
**时间复杂度**：O(n)  
**空间复杂度**：O(1)  
**技巧**：利用虚拟头节点，将原链表节点逐个插入到Dummy节点之后。

```
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode dummy = new ListNode(-1);
        
        while (head != null) {
            ListNode next = head.next;  // 保存下一个节点
            head.next = dummy.next;     // 当前节点插入dummy之后
            dummy.next = head;          // 更新dummy.next
            head = next;                // 移动原链表指针
        }
        
        return dummy.next;
    }
}
```

**适用场景**：
• 需要保持原链表不被破坏时
• 与其他链表操作结合使用（如部分反转）