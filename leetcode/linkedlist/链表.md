# Linked List Manipulation

## 206. Reverse Linked List 反转链表 简单

给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
 

示例 1：

> ![](../../pictures/206_1.jpg "")
>
> 输入：head = [1,2,3,4,5]
>
> 输出：[5,4,3,2,1]

示例 2：

> ![](../../pictures/111_1.jpg "")
>
> 输入：head = [1,2]
> 输出：[2,1]

示例 3：

> 输入：head = []
>
> 输出：[]
 
提示：

- 链表中节点的数目范围是 [0, 5000]
- -5000 <= Node.val <= 5000

**进阶**：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

### **解法 1：迭代法**
**时间复杂度**：O(n)  
**空间复杂度**：O(1)  
**核心思想**：使用三个指针（prev, curr, next）逐步反转链表。

```
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        
        while (curr != null) {
            ListNode next = curr.next; // 保存下一个节点
            curr.next = prev;          // 反转当前节点的指针
            prev = curr;               // prev指针后移
            curr = next;               // curr指针后移
        }
        
        return prev;	// prev最终指向新头节点
    }
}
```

**关键点**：
1. **三指针协同**：`prev` 记录前驱节点，`curr` 处理当前节点，`next` 临时保存后续节点
2. **终止条件**：`curr == null` 时，`prev` 指向新头节点
3. **空间高效**：仅使用常数空间


### **解法 2：递归法**
**时间复杂度**：O(n)  
**空间复杂度**：O(n)（递归栈）  
**思路**：递归到链表末端，回溯时逐层反转指针。

```
// labuladong p446
// 不要跳进递归。
class Solution {
    public ListNode reverseList(ListNode head) {
        // 基线条件：空链表或单节点链表
        if (head == null || head.next == null) {
            return head;
        }
        
        ListNode newHead = reverseList(head.next); // 递归反转后续链表
        head.next.next = head; // 反转当前节点与下一节点的指针
        head.next = null;      // 避免循环引用
        
        return newHead; // 始终返回新的头节点
    }
}
```

**关键点**：
1. **递归终止**：链表为空或只剩一个节点时直接返回
2. **回溯反转**：从链表末端向前逐个反转指针
3. **缺点**：链表过长时可能导致栈溢出

---

### **解法 3：头插法（Dummy Node）**
**时间复杂度**：O(n)  
**空间复杂度**：O(1)  
**技巧**：利用虚拟头节点，将原链表节点逐个插入到Dummy节点之后。

```
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode dummy = new ListNode(-1);
        
        while (head != null) {
            ListNode next = head.next;  // 保存下一个节点
            head.next = dummy.next;     // 当前节点插入dummy之后
            dummy.next = head;          // 更新dummy.next
            head = next;                // 移动原链表指针
        }
        
        return dummy.next;
    }
}
```

**适用场景**：
- 需要保持原链表不被破坏时
- 与其他链表操作结合使用（如部分反转）

## 92. Reverse Linked List II 反转链表 II 中等

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 **反转后的链表** 。
 
示例 1：

> ![](../../pictures/92_1.jpg "")
>
> 输入：head = [1,2,3,4,5], left = 2, right = 4
>
> 输出：[1,4,3,2,5]

示例 2：

> 输入：head = [5], left = 1, right = 1
>
> 输出：[5]
 

提示：

- 链表中节点数目为 n
- 1 <= n <= 500
- -500 <= Node.val <= 500
- 1 <= left <= right <= n
 
**进阶**： 你可以使用一趟扫描完成反转吗？

### 使用 **206. 反转链表** 的解法

**方法思路**
我们可以利用206题的反转链表方法来解决92题。具体步骤如下：
1. 找到需要反转的子链表的前驱节点和后继节点
2. 将子链表单独截取出来
3. 使用206题的方法反转子链表
4. 将反转后的子链表重新连接回原链表

```
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        // 创建虚拟头节点处理left=1的情况
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
        ListNode preLeft = dummy;
        for (int i = 0; i < left - 1; i++) {
            preLeft = preLeft.next;
        }

        // 第 2 步：从 preLeft 再走 right - left + 1 步，来到 right 节点
        ListNode rightNode = preLeft;
        for (int i = left; i <= right; i++) {
            rightNode = rightNode.next;
        }

        // 第 3 步：切断出一个子链表（截取链表）
        ListNode leftNode = preLeft.next;
        ListNode postRight = rightNode.next;

        // 注意：切断链接
        preLeft.next = null;
        rightNode.next = null;

        // 第 4 步：同第 206 题，反转链表的子区间
        reverseList(leftNode);

        // 第 5 步：接回到原来的链表中
        preLeft.next = rightNode;
        leftNode.next = postRight;

        return dummy.next;
    }

    // 206.反转链表的迭代解法 也可以使用递归反转一个链表
    private void reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
    }
}
```