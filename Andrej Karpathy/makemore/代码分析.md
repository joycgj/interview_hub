```
b = {}
for w in words:
  chs = ['<S>'] + list(w) + ['<E>']
  for ch1, ch2 in zip(chs, chs[1:]):
    bigram = (ch1, ch2)
    b[bigram] = b.get(bigram, 0) + 1
```

这个代码片段的目的是统计词汇中的 **bigram**，即连续的两个字符对。具体步骤如下：

### 代码结构分析

```python
b = {}  # 初始化一个空字典，用于存储bigram及其出现次数
for w in words:  # 遍历每一个单词
    chs = ['<S>'] + list(w) + ['<E>']  # 将单词的字符转为列表，并在首尾加上起始符'<S>'和结束符'<E>'
    for ch1, ch2 in zip(chs, chs[1:]):  # zip将chs和chs[1:]配对，相邻的字符形成bigram
        bigram = (ch1, ch2)  # 形成一个元组，表示一个bigram
        b[bigram] = b.get(bigram, 0) + 1  # 更新字典b中的bigram计数，如果bigram存在则加1，否则设置为1
```

### 逐步解析

1. **初始化字典**:

   ```python
   b = {}
   ```

   `b`是一个空字典，用来保存bigram及其出现的次数。

2. **遍历单词**:

   ```python
   for w in words:
   ```

   这一行会遍历`words`列表中的每个单词`w`。

3. **字符分解**:

   ```python
   chs = ['<S>'] + list(w) + ['<E>']
   ```

   这行代码的作用是：

   * `list(w)`：将单词`w`转换为字符列表。
   * `['<S>'] + list(w) + ['<E>']`：在字符列表的前面加上`'<S>'`，在后面加上`'<E>'`，用于表示单词的开始和结束。

   例如，如果`w = "hello"`，那么`chs`会变成`['<S>', 'h', 'e', 'l', 'l', 'o', '<E>']`。

4. **生成bigram**:

   ```python
   for ch1, ch2 in zip(chs, chs[1:]):
   ```

   这一行使用`zip(chs, chs[1:])`来生成相邻的字符对（即bigram）。`zip(chs, chs[1:])`会将`chs`和`chs[1:]`中的元素配对，例如`chs = ['<S>', 'h', 'e', 'l', 'l', 'o', '<E>']`，就会生成以下配对：

   ```python
   ('<S>', 'h'), ('h', 'e'), ('e', 'l'), ('l', 'l'), ('l', 'o'), ('o', '<E>')
   ```

5. **更新计数**:

   ```python
   bigram = (ch1, ch2)
   b[bigram] = b.get(bigram, 0) + 1
   ```

   * `bigram = (ch1, ch2)`：将相邻的字符对作为一个元组`(ch1, ch2)`。
   * `b[bigram] = b.get(bigram, 0) + 1`：使用字典`b`来记录每个bigram的出现次数。如果`bigram`已经存在于字典中，`get(bigram, 0)`会返回它当前的计数（默认为0），然后加1；如果`bigram`不存在，则从0开始计数。

### 举个例子

假设有`words = ["hello", "world"]`。

1. 对于单词`"hello"`，`chs`变成了`['<S>', 'h', 'e', 'l', 'l', 'o', '<E>']`，生成的bigram是：

   * ('<S>', 'h')
   * ('h', 'e')
   * ('e', 'l')
   * ('l', 'l')
   * ('l', 'o')
   * ('o', '<E>')

2. 对于单词`"world"`，`chs`变成了`['<S>', 'w', 'o', 'r', 'l', 'd', '<E>']`，生成的bigram是：

   * ('<S>', 'w')
   * ('w', 'o')
   * ('o', 'r')
   * ('r', 'l')
   * ('l', 'd')
   * ('d', '<E>')

### 最终结果

字典`b`会存储每个bigram以及它出现的次数。比如，如果`words = ["hello", "world"]`，那么字典`b`可能会变成：

```python
{
    ('<S>', 'h'): 1,
    ('h', 'e'): 1,
    ('e', 'l'): 1,
    ('l', 'l'): 2,
    ('l', 'o'): 1,
    ('o', '<E>'): 1,
    ('<S>', 'w'): 1,
    ('w', 'o'): 1,
    ('o', 'r'): 1,
    ('r', 'l'): 1,
    ('l', 'd'): 1,
    ('d', '<E>'): 1
}
```

每个bigram及其出现次数被记录在字典中。

```
chars = sorted(list((set(''.join(words)))))
stoi = {s:i+1 for i, s in enumerate(chars)}
stoi['.'] = 0
itos = {i:s for s, i in stoi.items()}
```

这段代码的目的是为字符集创建一个 **字符到索引（stoi）** 和 **索引到字符（itos）** 的映射。具体来说，`stoi` 是从字符到索引的映射字典，而 `itos` 是从索引到字符的映射字典。

### 代码逐行分析

```python
chars = sorted(list((set(''.join(words)))))
```

1. **`''.join(words)`**：

   * 这里的 `words` 是一个包含多个单词的列表。`''.join(words)` 这个操作将所有单词连接成一个长字符串。
     例如，如果 `words = ["hello", "world"]`，那么 `''.join(words)` 会变成 `"helloworld"`。

2. **`set(''.join(words))`**：

   * 使用 `set()` 会将这个长字符串中的所有字符去重，得到唯一的字符集合。
     例如，`set("helloworld")` 会得到 `{'h', 'e', 'l', 'o', 'w', 'r', 'd'}`。

3. **`list(set(''.join(words)))`**：

   * 将这个字符集合转回成一个列表。列表中包含了所有的唯一字符。
     例如，`list({'h', 'e', 'l', 'o', 'w', 'r', 'd'})` 会得到一个无序的字符列表。

4. **`sorted(list(set(''.join(words))))`**：

   * `sorted()` 将字符列表按字母顺序排序。最终结果是一个排序后的字符列表。
     例如，`sorted(['h', 'e', 'l', 'o', 'w', 'r', 'd'])` 会得到 `['d', 'e', 'h', 'l', 'o', 'r', 'w']`。

### 构建 `stoi` 字典

```python
stoi = {s:i+1 for i, s in enumerate(chars)}
```

1. **`enumerate(chars)`**：

   * `enumerate(chars)` 返回一个可枚举对象，返回元素的索引和值。例如，对于 `chars = ['d', 'e', 'h', 'l', 'o', 'r', 'w']`，`enumerate(chars)` 会生成如下的对 `(0, 'd')`, `(1, 'e')`, `(2, 'h')` 等。

2. **字典推导式 `{s:i+1 for i, s in enumerate(chars)}`**：

   * 这行代码将为每个字符 `s` 分配一个索引 `i+1`（索引从 1 开始，而不是 0）。所以，`stoi` 字典的结构将是：

     * 每个字符对应的值是它在列表中的位置（加1），如：

       ```python
       {'d': 1, 'e': 2, 'h': 3, 'l': 4, 'o': 5, 'r': 6, 'w': 7}
       ```

### 添加 `'.'` 到 `stoi` 字典

```python
stoi['.'] = 0
```

* 这一行手动将字符 `'.'` 添加到 `stoi` 字典中，并将它的值设置为 `0`。通常，`'.'` 是用作 "结束符" 或 "填充符"。这行代码确保 `'.'` 是一个特殊字符并赋予它索引 `0`。

最终，`stoi` 字典可能是这样的：

```python
{
    'd': 1,
    'e': 2,
    'h': 3,
    'l': 4,
    'o': 5,
    'r': 6,
    'w': 7,
    '.': 0
}
```

### 构建 `itos` 字典

```python
itos = {i:s for s, i in stoi.items()}
```

* 这行代码是通过反转 `stoi` 字典来创建 `itos` 字典，即从索引到字符的映射。
* `stoi.items()` 返回 `stoi` 字典中的 `(key, value)` 对，`s` 是字符，`i` 是索引。
* `{i:s for s, i in stoi.items()}` 将这些 `(key, value)` 对颠倒位置，生成新的字典，其中索引作为键，字符作为值。

假设 `stoi` 字典为：

```python
{
    'd': 1,
    'e': 2,
    'h': 3,
    'l': 4,
    'o': 5,
    'r': 6,
    'w': 7,
    '.': 0
}
```

那么，`itos` 字典将是：

```python
{
    1: 'd',
    2: 'e',
    3: 'h',
    4: 'l',
    5: 'o',
    6: 'r',
    7: 'w',
    0: '.'
}
```

### 总结

* `stoi`（字符到索引映射）是为每个唯一字符分配一个索引，`'.'` 被赋予了索引 `0`，其余字符从 `1` 开始。
* `itos`（索引到字符映射）是 `stoi` 的反转，每个索引对应一个字符。

这些映射常用于文本处理、自然语言处理（NLP）等任务中，尤其是在处理字符级别的输入时。


```
import matplotlib.pyplot as plt
%matplotlib inline

plt.figure(figsize=(16, 16))
plt.imshow(N, cmap='Blues')
for i in range(28):
  for j in range(28):
    chstr = itos[i] + itos[j]
    plt.text(j, i, chstr, ha='center', va='bottom', color='gray')
    plt.text(j, i, N[i, j].item(), ha='center', va='top', color='gray')
plt.axis('off')
```

这段代码使用 `matplotlib` 库生成一个 **28x28** 网格的图像，图像中的每个格子展示了两个部分的信息：字符的组合（由 `itos[i]` 和 `itos[j]` 组成）和网格中对应的值。下面是代码的详细解释：

### 代码分析

```python
import matplotlib.pyplot as plt
%matplotlib inline
```

1. **`import matplotlib.pyplot as plt`**：

   * 导入 `matplotlib` 的 `pyplot` 模块，并将其重命名为 `plt`。`matplotlib` 是一个用于绘制图形的库，`pyplot` 是其常用的接口。

2. **`%matplotlib inline`**：

   * 这是一条 Jupyter notebook 特有的魔法命令，用来确保图形直接嵌入在 notebook 中显示，而不是在新窗口中弹出。

```python
plt.figure(figsize=(16, 16))
```

3. **`plt.figure(figsize=(16, 16))`**：

   * 创建一个新图形，并设置图形的尺寸为 `16x16` 英寸（即大尺寸的画布）。`figsize` 参数接受一个包含宽度和高度的元组，单位是英寸。

```python
plt.imshow(N, cmap='Blues')
```

4. **`plt.imshow(N, cmap='Blues')`**：

   * `plt.imshow()` 用于显示一个图像，`N` 应该是一个二维数组（例如 28x28 的矩阵），它表示要绘制的数据。
   * `cmap='Blues'` 指定了颜色图（colormap），这表示图像会用蓝色的渐变来展示数据的值。

```python
for i in range(28):
  for j in range(28):
    chstr = itos[i] + itos[j]
    plt.text(j, i, chstr, ha='center', va='bottom', color='gray')
    plt.text(j, i, N[i, j].item(), ha='center', va='top', color='gray')
```

5. **双层 `for` 循环**：

   * 这两个嵌套的 `for` 循环遍历了一个 28x28 的网格，即从 `i=0` 到 `i=27` 和从 `j=0` 到 `j=27`，共进行 `28*28` 次循环。
   * 每个格子的位置 `(i, j)` 对应于 `N[i, j]` 的一个数值，并在这个位置添加两段文本。

6. **`chstr = itos[i] + itos[j]`**：

   * `itos[i]` 和 `itos[j]` 是索引到字符的映射。`itos` 字典将索引映射到字符，因此这行代码生成了每个格子中显示的字符组合 `chstr`，即两个字符的连接。
   * 例如，`itos[1] + itos[2]` 会得到 `'de'`（如果 `itos[1] = 'd'` 和 `itos[2] = 'e'`）。

7. **`plt.text(j, i, chstr, ha='center', va='bottom', color='gray')`**：

   * 在位置 `(j, i)` 处添加文本 `chstr`。
   * `ha='center'` 将文本水平居中。
   * `va='bottom'` 将文本垂直对齐到文本的底部。
   * `color='gray'` 设置文本的颜色为灰色。

8. **`plt.text(j, i, N[i, j].item(), ha='center', va='top', color='gray')`**：

   * 在相同的位置 `(j, i)` 上再添加一段文本，这次文本是 `N[i, j]` 的值。
   * `N[i, j].item()` 用来从 NumPy 数组中提取标量值（如果 `N[i, j]` 是一个张量）。
   * `ha='center'` 将数字文本水平居中。
   * `va='top'` 将数字文本垂直对齐到文本的顶部。
   * `color='gray'` 设置文本颜色为灰色。

```python
plt.axis('off')
```

9. **`plt.axis('off')`**：

   * 关闭坐标轴的显示。这样，图像的坐标轴（x轴和y轴的刻度及标签）不会显示在图中，只显示图像本身。

### 总结

这段代码的目的是生成一个 28x28 的网格，其中每个格子包含两个信息：

* **字符组合**：由 `itos[i] + itos[j]` 生成，表示两个字符的组合。
* **数字值**：由 `N[i, j]` 提供，表示网格中对应位置的数值。

图像使用了蓝色渐变来展示 `N` 数值的强度，并在每个网格中展示了字符和数字，旨在为某些数据可视化或矩阵分析提供直观的展示。


```
g = torch.Generator().manual_seed(2147483647)
p = torch.rand(3, generator=g)
p = p / p.sum()
```


这段代码使用了 **PyTorch** 庆祝生成随机数，并且进行了归一化处理。每一行的功能如下：

### 代码逐行解析

```python
g = torch.Generator().manual_seed(2147483647)
```

1. **`torch.Generator()`**：

   * `torch.Generator()` 用于创建一个新的随机数生成器。生成器控制随机数的种子，并可以产生不同的随机数序列。默认情况下，PyTorch 使用系统时间来生成种子，但可以通过手动设置种子来控制随机数生成的行为。

2. **`.manual_seed(2147483647)`**：

   * `.manual_seed()` 方法用于设置随机数生成器的种子。这个方法确保每次使用相同的种子时生成相同的随机数序列。`2147483647` 是一个非常大的整数值，这里作为种子。
   * 由于使用了固定的种子，`g` 会生成相同的随机数序列，不同的地方在于每次运行代码时，这个种子能确保生成相同的随机数。

   **解释**：

   * 这个种子值 `2147483647` 是一个常见的最大 32 位有符号整数的值（即 2³¹ - 1）。其使用意味着随机数生成的行为在这个范围内是可复现的。

```python
p = torch.rand(3, generator=g)
```

3. **`torch.rand(3, generator=g)`**：

   * `torch.rand(3)` 会生成一个包含 3 个随机数的张量。默认情况下，这些随机数在 \[0, 1) 区间内均匀分布。
   * `generator=g` 参数表示使用前面创建的随机数生成器 `g`，也就是说，这些随机数是由种子 `2147483647` 决定的。

   **结果**：

   * `p` 会是一个包含 3 个随机数的张量，假设生成的是 `[0.123, 0.456, 0.789]`（具体值取决于种子）。

```python
p = p / p.sum()
```

4. **`p.sum()`**：

   * `p.sum()` 计算张量 `p` 中所有元素的和。如果 `p = [0.123, 0.456, 0.789]`，那么 `p.sum()` 就是这 3 个数的和，即 `0.123 + 0.456 + 0.789 = 1.368`。

5. **`p = p / p.sum()`**：

   * 通过对张量 `p` 除以它的总和，确保 `p` 的元素加起来为 1。这是一个常见的 **归一化** 操作。
   * 这样会将原来随机生成的数值按比例缩放，使得它们的总和等于 1。举个例子：

     * 如果原始 `p = [0.123, 0.456, 0.789]`，那么 `p.sum() = 1.368`。
     * 归一化后的 `p = [0.123/1.368, 0.456/1.368, 0.789/1.368]`，结果会是 `[0.090, 0.333, 0.577]`，这些数值的总和为 1。

### 总结

这段代码完成了以下操作：

1. 创建了一个 **随机数生成器** `g`，并使用 `2147483647` 作为种子确保每次生成相同的随机数序列。
2. 使用该生成器生成了一个包含 3 个随机数的张量 `p`，这些随机数在区间 \[0, 1) 内均匀分布。
3. 对张量 `p` 进行了归一化处理，使得它的所有元素加起来等于 1。

这样处理后的 `p` 可以看作是一个概率分布，因为它的所有元素加起来恰好是 1，适合用来表示一组随机事件的概率。


```
torch.multinomial(p, num_samples=20, replacement=True, generator=g)
```

这段代码使用了 **PyTorch** 的 `torch.multinomial()` 函数，从给定的概率分布 `p` 中进行多项式采样。以下是每个参数的详细解释：

### 代码解析

```python
torch.multinomial(p, num_samples=20, replacement=True, generator=g)
```

1. **`p`**：

   * `p` 是一个一维张量，表示一个概率分布。在这个上下文中，它是先前归一化后的随机张量，其元素和为 1，表示了从 3 个类别（或事件）中抽样的概率。
   * 例如，如果 `p = [0.090, 0.333, 0.577]`，这意味着第一个类别的概率是 0.090，第二个类别的概率是 0.333，第三个类别的概率是 0.577。

2. **`num_samples=20`**：

   * `num_samples` 是指定要从概率分布 `p` 中采样多少次。在这个例子中，我们要从 `p` 中采样 **20 次**。
   * 采样的结果是一个包含 20 个元素的张量，每个元素是从 `p` 中随机选择的一个索引，表示采样的类别。

3. **`replacement=True`**：

   * `replacement` 参数表示是否允许重复采样：

     * `True` 表示 **有放回采样**，即在每次采样后，所选类别仍然可以再次被选中。
     * `False` 表示 **无放回采样**，即每次采样后，被选中的类别不能再次被选中。
   * 在这个例子中，`replacement=True` 表示我们可以重复选择同一个类别，也就是说，即使某个类别已经被选中，我们仍然有可能再次选中它。

4. **`generator=g`**：

   * `generator` 参数指定了用于生成随机数的随机数生成器。在这里，使用的是之前定义的 `g` 生成器，该生成器使用了种子 `2147483647`，确保每次运行代码时生成相同的随机数序列。
   * 这对于确保结果可复现是很重要的。

### 功能

`torch.multinomial()` 从给定的概率分布 `p` 中 **进行多项式采样**，返回一个包含 `num_samples` 个索引的张量。这些索引表示从 `p` 中采样得到的类别。

### 返回值

`torch.multinomial()` 的返回值是一个张量，包含从 `p` 中采样出的类别的索引。

例如，假设 `p = [0.090, 0.333, 0.577]`，调用 `torch.multinomial(p, num_samples=20, replacement=True, generator=g)` 可能返回：

```python
tensor([2, 2, 1, 2, 0, 1, 2, 0, 2, 1, 2, 2, 2, 1, 0, 2, 0, 1, 2, 2])
```

这表示从 `p` 中按照给定的概率分布采样出的 20 个类别索引。在这个例子中：

* 索引 0 对应的类别被选中了 4 次。
* 索引 1 对应的类别被选中了 6 次。
* 索引 2 对应的类别被选中了 10 次。

### 例子总结

* 如果 `p = [0.090, 0.333, 0.577]`，这表示一个有 3 个类别的概率分布，其中第一个类别的概率为 0.090，第二个类别为 0.333，第三个类别为 0.577。
* 使用 `torch.multinomial()` 可以从这个分布中进行 20 次采样，返回一个包含 20 个采样结果的张量。
* 由于设置了 `replacement=True`，所以有可能出现重复的采样结果，选择的类别可以重复出现。

### 用途

这种采样方法通常用于：

* **分类问题**：从离散的类别中随机选择。
* **强化学习**：在策略中进行采样，根据某些概率分布来选择动作。
* **生成式模型**：如文本生成、图像生成等，从概率分布中生成样本。
